\chapter{Literature Survey}

This section will explain why there’s a need for this system by exploring background literature related to this subject. Mainly the need of a proper system to test scientific software, start with explaining what a scientific software is, following up by explaining why most of them are not tested correctly. Then we will be discussing some of the current method in testing and why are they insufficient. Next we will be discussing the two main components of this system, Cucumber and Behave. Then finally, explaining what casual testing is, the main method used by this system to test other software, and exhibit why it lacks a proper interactive system for non software engineering users. 

\section{Computational model}
Using a computational model for scientific research is common practice with today’s technology, scientists use these models to predict the result of an experiment or the outcome of an event. But whether these models can accurately predict the result, is still a problem since most of them lack some form of proper testing. Below will be discussing what is a computational model, why they are poorly tested, and some of the current testing method.
\subsection{Aspects of computational model}
What defines a scientific computational model, it’s by using computers to simulate and study real life events by using mathematics, statistics, physics, and computer science to study the mechanism and behavior of complex systems by computer simulation \cite{Reference1}. \\*\\*
There are two main ways to process model’s data, empirical and mechanistic:  \\*\\*
For empirical, researcher don’t need to know exactly how the system works, they just need to observe the outcome of certain scenario and predict what’s going to happen in the future[Empirical vs. Mechanistic Models REFERENCE]. For example, by observing how tides are going to change in a year, people can predict how the tides will change in the upcoming years. They don’t need to know the exact mechanism behind why and how the tides change, only require knowing the circumstance and the outcome. By using this method, it simplifies the model since there’s less complex calculation required. And it’s better to comprehend compared to mechanistic. The problem for empirical is it require a lot more input data to have good accuracy in the model, there won’t be much problem if the model is developed with big data and machine learning tools, but if the model don’t have enough data at the start, it will affect the model’s accuracy. \\*\\*
For mechanistic, it requires fewer input data to achieve the same accuracy as the empirical, but it is also more computationally intensive. Compared to empirical, it is easier to extrapolation, researchers can make predictions based on the previous input data. \\*\\*
Model also split into two types, agent based and equation-based model. \\*\\* 
For agent-based model, is a system is modeled as a collection of autonomous decision-making entities called agents. Agents will act based on the situation its in and the abilities it has(AGENT BASED MODEL REFERENCE). Agents with react appropriate to the rule defined for them, for example, in an agent-based model for honeybee, if a bee detect a flower near by with resource in it, the bee will move toward the flower and collect the resource. In this case, the bee agent is in a situation where there is flower with resource nearby, according to the rules define for the bee agent, it reacts by moving towards the flower and collect from it. \\*\\*
For equation-based model, instead of have agents with rules defined, it have a set of differential equations, the model uses equations to represent relationships between observables(EQUATION BASED MODEL REFERENCE), the situation of observables will change depend on the equation. For example, modeler can define an equation on how fast a disease will spread, by define a start infected population, the equation can then calculate how many people are infected in each given timestep. \\*\\*

\subsection{Purpose of computational model}
By using models that contain a number of input variables, and algorithms that will define the system. Researchers use these models to simulate real-life situations and adjust these models by changing their variable and algorithm according to the results to make the model more conform to reality. Then researchers can use these models to see how one or more variables can affect the outcome of a certain event. Computational models provided some level of prediction of being able to calculate an anticipated result from a given set of variables \cite{Reference4}. This forecasting system can be used to predict complex systems, such as weather or disease spread, and help researchers or decision makers to decide their next move.\\*\\*
An example of this kind of model is Covasim \cite{Reference5}, Covasim uses agents to simulate individual people, the model mainly focused on one type of calculation, what is the probability of an individual in a given time step will change from not infected to infected, or badly ill to death. \\*\\*
The simulation starts from loaded the parameters, then it will start creating individual with different age, sex, and comorbidities based on the selected location (i.e., Different country). Then will be grouped into a social network depending on their attributes. After that the model will start looping, in each step, the model will apply various operations on the individual, then collect the result and apply analysis.

\section{Testing computational model}
Computational models are often very complicated, and require special knowledge related to the field, so is testing computational model. This often results in some issue in testing, some methods have been developed to help with the testing process, but most are either to complicate or insufficient. There’s currently a more efficient way to test these models which is by using behavior-driven development (or BDD) and Cucumber. Combined with casual model testing, a way to draw relationships between variables, it will make testing these complex models a lot easier.

\subsection{Why computational models are hard to test}
Computational models are often developed by scientists themselves, but most scientists aren’t software developers and may not have knowledge in some common software engineering practices, this may cost the quality of the scientific software \cite{Reference6}. Software testing is one of the aspects that is impacted, since the lack of knowledge in software development, lack of understanding in systematic testing is expected. Mistake can be made without notice and may affect the output of the system, causing the result to become inaccurate.\\*\\*
Testing a scientific software itself can be a difficult task to do, this may be the result of two types of challenges: \\*\\*
First is due to the software’s main purpose is to predict something unknown or simulate areas even researchers have little knowledge in, but to test a software, it is crucial to know how the software should Behave, what kind of output should it show. 
Without these knowledge, it is hard to tell if the software is working the right way. \\*\\*
Furthermore, these computation models are often consisting of hundreds of parameters and complex algorithm, this means it would require lots of test case in order to test every aspect of the system, and this leads high execution time making the testing process become very time consuming \cite{Reference6}.\\*\\*
Second is that scientific software is mostly developed with scientists being the lead role instead of a software engineer, and the value of the software system is often underestimated \cite{Reference6}. And most scientists never went through the training in software design like software engineer \cite{Reference7}, this means limited understanding of the testing process and not applying known testing methods. This will make the core design of the software unfriendly for effective testing.

\subsection{Current testing method}
After modeler complete the modeling process, they are required to verify the model. 
Despite the rarely carried out practice, verification is an important step in modeling, it helps making sure the results produced by the model is accurate enough to represent the reality or the theory of the model. Verification is done by comparing the predication of the model with actual data. The type of compared data provide will determine whether the models is validated at the pattern, point, distribution, or value level, or some combination of these (CURRENT TESTING METHOD REFERENCCE). \\*\\*
This verification step can have some issue when it comes to models with multiple agents, modelers may be required to test the agent as an individual or in as a group, this is often determined by the requirement of the model. If the model’s main goal is focus on the broader environment, then its agents need to be verified as a group, for example in a model for researching bee colony’s behavior, the bee agents will be assessed as an entire hive instead of as individual bees. On the contrast, if the model’s goal is focus on individual agent, it will need to be verify as an individual.
The modelers will be required to collect data to compare it with the results of the model. This can make the verification process become very tedious and time consuming. 


\subsection{Behavior-driven development with Behave}
Behave is a python API based on behavior-driven development, where the goal is for people who don’t really understand programming code to be able to participate in the testing process. Behavior-driven development is a development technique that encourages collaboration between participants in a software project \cite{Reference8}. Behavior-driven development or BDD, aims to have a clear understanding of the desired software behavior between stakeholders and software developers, and communicate by writing test cases in a natural language that both sides can understand. Behave is a Python API created for this, it consists of tests written in Cucumber, another API written in natural language style. \\*\\*

When a test case is written, it requires a tool to read its specifications and see if the system works as the test-case specified. Cucumber is the tool that was developed for this purpose, it reads specifications written in plain text with a certain format and validates if the software does what those specifications say \cite{Reference9} and creates a report. \\*\\*

For the non-developers who want to participate in testing, they are required to create a feature file. The feature need be written in Gherkin language, Gherkin uses a set of grammar and special keywords to give plain text structure so that Cucumber could understand it, one of the pros for Gherkin is that keyword can be translated to other languages, making it usable for people who don’t speak English \cite{Reference10}. A proper Gherkin grammar starts by giving a context, then describing an event, and after that what should happen after the event. With these grammars, testers can specify a situation in the system, describe a certain parameter, and what the results should be with those parameters. By writing a test using Cucumber and Gherkin grammar, tester can combine them into a .Feature file as display below: 
\begin{figure}[h]
	\centering
	\includegraphics[width=10cm]{figures/featureFile.png}\\
	\caption{A feature file example.}
	\label{fig:figure1}
\end{figure}
\newpage \noindent 
\\*\\*

For developers, they are required to create a step decorator the matches the steps, for example in the above feature file example, there is a “given” type, therefore in step decorator will need to match it as below:
\begin{figure}[h]
	\centering
	\includegraphics[width=10cm]{figures/stepFile.png}\\
	\caption{A feature file example.}
	\label{fig:figure1}
\end{figure}

With the step file implemented, tester can execute the .feature file in terminal and Behave can read what needs to be tested and return a report. In this way, tester who don’t have sufficient knowledge can involve in testing phase, therefore making collaboration between developers and non-developer in a project become a lot easier.


\subsection{Testing computational model with causal testing}
Causal testing can be a really useful testing method for software engineers \cite{Reference13}, however computational models are often developed by scientists or researchers who have limited knowledge in software testing \cite{Reference8}. Tester who wants to use causal model as a way to test system needs to have prior knowledge in how variables work in a software, this means people who may not have that much knowledge in software engineering, for example researchers in other fields, might not be able to conduct this method of testing in their software.

\section{Summary}

Behave is a powerful testing tool for software tester’s, based on the behavior-driven development method, encouraging people who do not specialize in software engineering to take part in testing. Assisted by Cucumber, a tool where users can describe testing steps in an easy-to-understand manner, and Cucumber compile and produce the results. With causal model, testers can effectively test large and complex computational models, saving time by only test parts of the system one at a time and combining the results together. But the problem is that when using causal model testing, it is inaccessible for most people, due to its lack of user-friendly nature. In order to make it more user friendly, we can integrate Cucumber and Behave with it to make it where users can use causal model testing by using Behave and Cucumber specify the testing process.
